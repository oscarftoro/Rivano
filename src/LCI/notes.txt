fsharpi -r lib/FsLexYacc.Runtime.dll src/LCI/FOL.fs src/LCI/FolPar.fs src/LCI/FolLex.fs src/LCI/Parse.fs

fsharpi -r ~/Apps/FsLexYacc/bin/FsLexYacc.Runtime.dll FOL.fs FolPar.fs FolLex.fs Parse.fs

or

fsharpi -r  ../../packages/FsLexYacc.Runtime/lib/portable-net45+netcore45+wpa81+wp8+MonoAndroid10+MonoTouch10/FsLexYacc.Runtime.dll -r ../../packages/System.Runtime/lib/net462/System.Runtime.dll -r ../../packages/System.IO/lib/net462/System.IO.dll FOL.fs FolPar.fs FolLex.fs Parse.fs 


> fromString("let x = atom \"hola\" in x end");;
> open Parse;;
> fromString ("5-2");;
> let x = fromString("let y = 8 in y - 3 end");;  
> open LCI.Fol;;
> eval(x) [];;

implies

> open Parse;;
> open LCI.Fol;;
> fromString("true or false");;
val it : expr = Dyadic ("∨",CBool true,CBool false)
> let ff = fromString("true or false");;

val ff : expr = Dyadic ("∨",CBool true,CBool false)

> eval ff [];;
val it : value = Boolean 1
> let ff = fromString("true implies false");;

val ff : expr = Dyadic ("→",CBool true,CBool false)

> eval ff [];;                               
val it : value = Boolean 0
> let ff = fromString("true => false");;     

val ff : expr = Dyadic ("→",CBool true,CBool false)

> eval ff [];;                               
val it : value = Boolean 0
> 

> fromString("let x = atom \"poet\" in x or  atom \"rich\" end");;
val it : expr = Let ("x",Atom "poet",Dyadic ("∨",Var "x",Atom "rich"))
> fromString("let x = atom \"musician\" in x implies  atom \"rich\" end");;
val it : expr = Let ("x",Atom "musician",Dyadic ("→",Var "x",Atom "rich"))


Atomic formulas (atom)

> fromString("\"holi\"");;
val it : expr = CString "holi"
> fromString("\"3\"");;   
val it : expr = CString "3"
> fromString("atom \"3\"");;
val it : expr = Atom (CString "3")
> fromString("atom 3 + 2");;
val it : expr = Atom (Dyadic ("+",CInt 3,CInt 2))
> fromString("atom 3 + 2 * 3");;
val it : expr = Atom (Dyadic ("*",Dyadic ("+",CInt 3,CInt 2),CInt 3))
> fromString("atom true or false");;
val it : expr = Atom (Dyadic ("∨",CBool true,CBool false))

Equality and ForAll

> open Parse;;
> open LCI.Fol
- ;;
> fromString("2 = 2");;
val it : expr = Dyadic ("=",CInt 2,CInt 2)
> let eq = fromString("2 = 2");;

val eq : expr = Dyadic ("=",CInt 2,CInt 2)

> eval eq [];;
val it : value = Boolean 1
> fromString("forall x. x = 2");;
val it : expr = ForAll ("x",Dyadic ("=",Var "x",CInt 2))
> let fa = fromString("forall x. x = 2");;

val fa : expr = ForAll ("x",Dyadic ("=",Var "x",CInt 2))

> eval fa [];;                            
val it : value = Boolean 0


Lists
------

fromString("let x = [1,2,3,4] in x end");;